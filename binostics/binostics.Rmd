---
title: "binostics: computing scagnostics measures in R and C++"
author:
  - name: Ursula Laa
    affiliation: Affiliation
    address:
    - line 1
    - line 2
    email:  author1@work
  - name: Dianne Cook
    affiliation: Affiliation
    address:
    - line 1
    - line 2
    email:  author2@work
  - name: Hadley Wickham
    affiliation: Affiliation
    address:
    - line 1
    - line 2
    email:  author3@work
  - name: Heike Hofmann
    affiliation: Affiliation
    address:
    - line 1
    - line 2
    email:  author4@work
abstract: >
  An abstract of less than 150 words.
preamble: |
  % Any extra LaTeX you need in the preamble
output: rticles::rjournal_article
---

## Introduction

- scatter plot matrix, need for variable selection with big data
- scagnostics [@scag,@WW08]: characterise scatterplots with 8 summaries (scatterplot diagnostics), select interesting plots from a SPLOM of the scagnostics measures and interactively look at those
- similar methods (e.g. MIC[@Reshef1518], available via minerva package [@minerva])
- alternative methods to see combinations of variables: tours [@As85,@tourr], PCA, LDA, PP [@f87]

things to mention: scagnostics package (CRAN) [@LWscagR], mbgraphic [@mbgraphic] (archived!) and Katrins thesis work [@Grimm2016]

## Scagnostics measures

Following @scag the scagnostics measures are evaluated on the data after hexagon binning, and based on the Delaunay triangulation for comutational efficiency. In addition, outlying points are removed before computing the measures (with exception of the Outlying measure), to make the measures more robust.

### Underlying definitions
All measures are based on graphs, i.e. a set of vertices and edges, that can all be extracted from the Delaunay triangulation, namely:

- the convex hull, i.e. the outer edges of the Delaunay triangulation
- the alpha hull [@1056714]
- the minimum spanning tree (MST) [@kruskal1956] 

In the following, the length of the MST is defined as the sum of lengths of all edges, and $q_x$ is defined as the $x$th percentile of the MST edge lengths.


When computing the alpha hull, $\alpha$ is set to $q_{90}$ [@scag]. The definition of outlying points is also based on edge length, with points being tagged as outlying if all adjacent edges in the MST have a lenght larger than
\begin{equation}
w = q_{75} + 1.5 ( q_{75} - q_{25}).
\label{eq:w}
\end{equation}
Several of the measures are corrected for dependence on sample size using the weight
\begin{equation}
\omega = 0.7 + \frac{0.3}{1+t^2},
\end{equation}
where $t = n / 500$ and $n$ the sample size. This correction weight was determined by comparing the scagnostics measures over a large number of datasets [@scag].

### Measure definitions

- **Outlying**: compares the edge lengths of the MST of outlying points with the length of the original MST T 
\begin{equation}
c_{\mathrm{outlying}} = \frac{length(T_{\mathrm{outliers}})}{length(T)}
\end{equation}
- **Skewed**: is measuring skewness in the distribution of MST edge lengths (and thus large values might not correspond to skewed distributions of points) as
\begin{equation}
c'_{\mathrm{skewed}} = \frac{q_{90}-q_{50}}{q_{90}-q_{10}},
\end{equation}
and is corrected to adjust for dependence on the sample size as
\begin{equation}
c_{\mathrm{skewed}} = 1 - \omega (1 - c'_{\mathrm{skewed}}).
\end{equation}
- **Sparse**: detects if points are only found in small number of locations in the plane, as is the case for categorical variables,
\begin{equation}
c_{\mathrm{sparse}} = \omega q_{90}.
\end{equation}
- **Clumpy**: to detect clustering we split the MST in two parts by removing a single edge $j$, and compare the largest edge lenght within the smaller of the two subsets to the length of the removed edge $j$. The clumpy measure is defined by maximising over all edges in the MST as
\begin{equation}
c_{\mathrm{clumpy}} = \max_j [1 - \max_k[\mathrm{length}(e_k)] / \mathrm{length}(e_j) ],
\end{equation}
with $k$ running over all edges in the smaller subgraph found after removing edge $j$ from the MST.
- **Striated**: aims to detect patterns like smooth algebraic functions or parallel lines, by evaluating the angles between adjacent edges,
\begin{equation}
c_{\mathrm{striated}} = \frac{1}{|V|} \sum_{v\in V^{(2)}} I(\cos\theta_{e(v,a)e(v,b)} < -0.75),
\end{equation}
where $V$ is the set of vertices, $|V|$ the total number of vertices in the triangulation, $V^{(2)}$ the subset of vertices with two edges (i.e. vertices of degree two), and $I$ the indicator function.
- **Convex**: convexity is computed as the ratio of the area of the alpha hull $A$ and the convex hull $H$, adjusting for sample size dependence,
\begin{equation}
c_{\mathrm{convex}} = \omega \frac{area(A)}{area(H)}.
\end{equation}
- **Skinny**: The ratio of the perimeter to the area of the alpha hull $A$, with normalization such that zero corresponds to a full circle and values close to 1 indicate a skinny polygon,
\begin{equation}
c_{\mathrm{skinny}} = 1 -  \frac{\sqrt{4\pi area(A)}}{perimeter(A)}.
\end{equation}
- **Stringy**: a stringy distribution should have no branches in the MST. This is evaluated by counting the number of vertices of degree two and comparing them to the total number of vertices (dropping those of degree one),
\begin{equation}
c_{\mathrm{stringy}} = \frac{|V^{(2)}|}{|V| - |V^{(1)}|}.
\end{equation}
- **Monotonic**: monotonicity is evaluated via the squared Spearman correlation coefficient, i.e. the Pearson correlation between the ranks of $x$ and $y$,
\begin{equation}
c_{\mathrm{monotonic}} = r_{\mathrm{Spearman}}^2.
\end{equation}

XXX maybe there is a problem with the implementation of outlying, because this sometimes gives values larger than one? (e.g. vs vs am on mtcars, also gives NaN for several other measures: clumpy, striated, stringy, monotonic)


## Interface

The elementary function in the binostics package `scagnostics` and can be called with a pair of vectors or a two-dimensional data structure (a matrix or data frame).

The default S3 method is for a pair of vectors and will compute the scagnostics measures for a single scatter plot. In this case additional control and output. The additional arguments `bins` and `outlierRmv` can be used for detailed checkes, but should not be necessary for most applications. The output in this mode is a named list `out`, with `out$s` reporting the scagnostics measures for the scatter plot, and `out$bins` returns the binned data used to compute them. Note that only non-empty bins are kept, and the format is a $3\times n$ matrix where the columns correspond to the bin position in $x, y$ and the bin count, and each row is a non-empty bin. Internally the x and y axis is mapped to integer numbers, and the bin size is reset if there are more than 250 non-empty bins, and this is reflected in the matrix returned to the user.

In most applications we are interested in the scagnostics measures for all combinations of variables in the input data. This is evaluated when passing a matrix or data frame to the `scagnostics` function. In this mode the function returns a data frame, where each row corresponds to one combination of variables, and we have one column for each scagnostics index. Two additional columns `var1` and `var2` report the corresponding variable names.

Finally, we may only be interested in a single scagnostics index for a pair of vectors. Since the measures all rely on the underlying binning and triangulation we simply provide wrapper functions to access this information conveniently. These functions are named according after the corresponding scagnostics measure and report the index as an unnamed scalar. This mode would be preferred e.g. when using the measure as a projection pursuit index.


## Implementation connecting R and C++

The interface is written in R and handels the reading the input, finds all combinations of variables in  the case of matrix input. For each pair of variables it then pre-processes the data: entries with missing values in either of the two variables are dropped, and each variable is centered and scaled by its range. It is then using a direct call to C++ for the computation of the measures, as described below, and finally collecting and formatting the output as described above.

The underlying C++ implementation allows for a fast evaluation, in particular it handles the binning and triangulation. The triangulation is used to determine the MST, convex hull and alpha hull, which are then used to compute the measures. The calculation is done in the following steps:

- Binning of the data: we use hexagonal binning, where the number of bins is a free parameter. Note that if this results in more than 250 non-empty bins in the result, half the number of bins will be used instead.
- Computing the Delaunay triangulation and the MST
- Outlier detection: we use a cutoff on the edge length (see Eq. \ref{eq:w}), to identify outlying points. The triangulation and computation of the MST are repeated after removing the tagged outliers.
- Compute scagnostics measures.


## Example

A simple example showcasing how to use scagnostics measures

```{r example, eval=F}

# FIXME need better examples!

library(tidyverse)
s <- binostics::scagnostics(mtcars)
s_tibble <- tibble::as_tibble(s[1:nrow(s),]) %>% #get tibble for plotting
  dplyr::mutate(vars = rownames(s))
GGally::ggpairs(select(s_tibble, -vars))
filter(s_tibble, Skinny==1 & Convex==1)$vars # these are discrete values only on the "outside"
filter(s_tibble, Skinny==1 & Convex==0)$vars # other discrete values give Convex=0
filter(s_tibble, Outlying==2 & Skewed==0)$vars # also points to discrete values only on the "outside"
```

## Interactive graphics

Show how to use plotly to identify which variables lead to outliers on a SPLOM of scagnostics measures?

## Summary

- scagnostics measures useful when exploring large datasets
- the binostics implementaton is efficient thanks to c++ interface, and portable (no java dependence)
- most useful for interactive exploration (maybe good to use in Shiny app?)
- connection with PP (cite PPI paper)

\bibliography{RJreferences}
